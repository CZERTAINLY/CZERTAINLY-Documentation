"use strict";(self.webpackChunkczertainly=self.webpackChunkczertainly||[]).push([[671],{72217:function(e,n,r){r.r(n),r.d(n,{GenTable:function(){return h},assets:function(){return c},contentTitle:function(){return o},data:function(){return l},default:function(){return m},frontMatter:function(){return i},metadata:function(){return d},toc:function(){return g}});var t=r(85893),s=r(11151),a=r(67294);const i={},o="Generate Assigned Keys",d={id:"signing/timed-services/generate-assigned-keys/overview",title:"Generate Assigned Keys",description:"The generate assigned keys timed service will pre-generate a number of keys based on the provided criteria. The main purpose of the service is taking care of having the keys prepared for signing operation in advance and not having to wait for the key generation process to complete during the signing operation, which can be time consuming. The signature application can take one of available pre-generated keys and use it for issuing the certificate and signing operation.",source:"@site/docs/30-signing/50-timed-services/03-generate-assigned-keys/01-overview.mdx",sourceDirName:"30-signing/50-timed-services/03-generate-assigned-keys",slug:"/signing/timed-services/generate-assigned-keys/overview",permalink:"/docs/signing/timed-services/generate-assigned-keys/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/3KeyCompany/CZERTAINLY-Documentation/edit/documentation/docs/30-signing/50-timed-services/03-generate-assigned-keys/01-overview.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Timed Services",permalink:"/docs/signing/timed-services/overview"},next:{title:"Sample Properties",permalink:"/docs/signing/timed-services/generate-assigned-keys/sample-properties"}},c={},l=[{property:"CRYPTOTOKEN",description:(0,t.jsx)(t.Fragment,{children:"The name of the crypto token where we want to generate the keys."}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"NONE"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--success",children:"YES"})})},{property:"TARGET_NUMBER_OF_PRE_GENERATED_KEYS",description:(0,t.jsx)(t.Fragment,{children:"The number of keys to should be available for the crypto token. The service will generate keys until this number is reached."}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"10"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--danger",children:"NO"})})},{property:"MAXIMAL_NUMBER_OF_KEYS_TO_GENERATE_PER_RUN",description:(0,t.jsx)(t.Fragment,{children:"The maximal number of keys to generate in one execution of the service. The service will generate keys until the target number of keys is reached."}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"100"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--danger",children:"NO"})})},{property:"FILTER_PROPERTY_NAME",description:(0,t.jsxs)(t.Fragment,{children:["The name of the property to filter on. The value of the property must match the ",(0,t.jsx)("b",{children:"FILTER_VALUE"}),"."]}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"Key specification"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--danger",children:"NO"})})},{property:"FILTER_VALUE",description:(0,t.jsxs)(t.Fragment,{children:["The value of the property to filter on. The value of the property must match the ",(0,t.jsx)("b",{children:"FILTER_PROPERTY_NAME"}),"."]}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"assigned=true, certified=false, enabled=false"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--danger",children:"NO"})})},{property:"KEYALIAS_PREFIX",description:(0,t.jsx)(t.Fragment,{children:"The prefix to use for the key aliases of the generated keys."}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"pregenerated"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--danger",children:"NO"})})},{property:"KEYGEN_ALGORITHM",description:(0,t.jsx)(t.Fragment,{children:"The algorithm to use for key generation."}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"NONE"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--success",children:"YES"})})},{property:"KEYGEN_SPECIFICATION",description:(0,t.jsx)(t.Fragment,{children:"The key specification to use for key generation."}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"NONE"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--success",children:"YES"})})},{property:"REQUIRES_TRANSACTION",description:(0,t.jsx)(t.Fragment,{children:"If the key generation requires a database transaction. If set to true, the service will run in a transaction."}),default:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--secondary",children:"false"})}),mandatory:(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("span",{className:"badge badge--danger",children:"NO"})})}],h=({data:e})=>{const n={b:"b",td:"td",tr:"tr",...(0,s.a)()};return(0,t.jsx)(a.Fragment,{children:e.map(((e,r)=>(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.b,{children:e.property})}),(0,t.jsx)(n.td,{children:e.description}),(0,t.jsx)(n.td,{children:e.default}),(0,t.jsx)(n.td,{children:e.mandatory})]},r)))})},g=[{value:"Limitations",id:"limitations",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"generate-assigned-keys",children:"Generate Assigned Keys"}),"\n",(0,t.jsx)(n.p,{children:"The generate assigned keys timed service will pre-generate a number of keys based on the provided criteria. The main purpose of the service is taking care of having the keys prepared for signing operation in advance and not having to wait for the key generation process to complete during the signing operation, which can be time consuming. The signature application can take one of available pre-generated keys and use it for issuing the certificate and signing operation."}),"\n",(0,t.jsx)(n.p,{children:"The implementation class of this service is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"com.czertainly.signserver.module.timedservices.keygeneration.GenerateAssignedKeys\n"})}),"\n",(0,t.jsx)(n.p,{children:"The following properties are available for this service:"}),"\n","\n","\n",(0,t.jsxs)("table",{children:[(0,t.jsx)("th",{children:"Property"}),(0,t.jsx)("th",{children:"Description"}),(0,t.jsx)("th",{children:"Default Value"}),(0,t.jsx)("th",{children:"Mandatory"}),(0,t.jsx)("tbody",{children:(0,t.jsx)(h,{data:l})})]}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.p,{children:"The service will generate keys until the target number of keys is reached. If the target number of keys is not reached, the service will generate the maximal number of keys per run. The service will not generate more keys than the target number of keys."}),"\n",(0,t.jsxs)(n.p,{children:["Depending on the underlying technology of the CryptoToken, you might experience performance issues if you generate a large number of keys in one go. If you experience performance issues, you might want to lower the value of the ",(0,t.jsx)(n.code,{children:"MAXIMAL_NUMBER_OF_KEYS_TO_GENERATE_PER_RUN"})," property and execute the service more often. It is recommended to test the performance of the service in your environment before using it in production."]}),"\n",(0,t.jsx)(n.p,{children:"The default transaction timeout for the service is 300 seconds (5 minutes). If the service needs to use the database and takes longer than that to execute, the transaction will be rolled back and the keys will not be generated. If you experience this issue, you might want to tweak the configuration of the service to generate fewer keys more often or build a separate instance that will be responsible only for generating keys in the shared database cluster."})]})}function m(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},11151:function(e,n,r){r.d(n,{Z:function(){return o},a:function(){return i}});var t=r(67294);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);